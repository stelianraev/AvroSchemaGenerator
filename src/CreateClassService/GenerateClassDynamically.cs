namespace AutomatizationVersionUpdate.CreateClassService
{
    using System.CodeDom;
    using System.CodeDom.Compiler;
    using AutomatizationVersionUpdate.AvroService.Models;
    using System.Reflection;
    using AutomatizationVersionUpdate.Services;
    using Microsoft.CSharp;
    using Newtonsoft.Json;
    using AutomatizationVersionUpdate.AvroService;
    using AutomatizationVersionUpdate.CreateClassService.Enums;
    using System;

    public class GenerateClassDynamically : Services
    {
        private readonly ClassGenerateSettings _settings;
        private readonly GenerateAvroSchemaDynamically _schemaGen;
        public GenerateClassDynamically(ClassGenerateSettings settings = null)
        {
            _settings = settings;
            _schemaGen = new GenerateAvroSchemaDynamically();
        }

        /// <summary>
        /// Core method used to generate Avro compatable Model from another Model
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="className"></param>
        /// <param name="nameSpace"></param>
        /// <param name="settings"></param>
        public void GenerateClassFromExistingClass<T>(string className = null, string nameSpace = null, ClassGenerateSettings settings = null) where T : class
        {
            if (String.IsNullOrEmpty(className) || String.IsNullOrWhiteSpace(className))
            {
                className = "AutoGeneratedClassName";
            }
            if (String.IsNullOrEmpty(nameSpace) || String.IsNullOrWhiteSpace(nameSpace))
            {
                nameSpace = typeof(T).Namespace;
            }

            var genClass = new ClassLayout()
            {
                Name = className,
                Type = className,
                ClassCollection = new List<ClassLayout>(),
                Namespace = nameSpace,
                Properties = new Dictionary<string, dynamic>()
            };

            ClassGen(typeof(T), genClass, new List<ClassLayout>(), settings);

        //    if (settings.IsSeparateClasses == true)
        //    {
                var dublicates = new List<string>();                

                //GetPropertyCollection(typeof(T), genClass, new List<ClassLayout>(), settings);

                //ClassGen(typeof(T), genClass, new List<ClassLayout>(), settings);

                GetSeparateClasses(genClass, dublicates, settings);
        //    }
            //Temporary disable it
        //    else
        //    {
        //        //var popProp = GetPropertyCollection(typeof(T), new ClassLayout(), new List<ClassLayout>(), settings);
        //        //var popProp = ClassGen(typeof(T), genClass, new List<ClassLayout>(), settings);
        //        var result = CreateNameSpace(genClass, genClass.Name);
        //        WriteFile(result, className, "cs", nameSpace, settings.SaveFileDirectory);
        //    }
        }

        /// <summary>
        /// Set Class properties depends on types. Used Reflection to iterate properties from given model and set collection to the new one
        /// </summary>
        /// <param name="properties"></param>
        /// <param name="classLayout"></param>
        /// <param name="classDublicates"></param>
        /// <param name="settings"></param>
        /// <returns></returns>
        private ClassLayout GetClassPropertyCollection(PropertyInfo[] properties, ClassLayout classLayout, string nmspace, List<ClassLayout> classDublicates, ClassGenerateSettings settings = null)
        {
            var dictionary = new Dictionary<string, dynamic>();
            classLayout.Properties = dictionary;
            classLayout.ClassCollection = new List<ClassLayout>();
            classLayout.PropertyInfos = new List<PropertyInfo>();

            foreach (var prop in properties)
            {
                classLayout.PropertyInfos.Add(prop);

                if (prop.Name == "TennisStream")
                {

                }

                if (prop.PropertyType == typeof(int))
                {
                    dictionary[prop.Name] = "System.Int32";
                    continue;
                }
                if (prop.PropertyType == typeof(long))
                {
                    dictionary[prop.Name] = "System.Int64";
                    continue;
                }
                else if (prop.PropertyType == typeof(string))
                {
                    dictionary[prop.Name] = "System.String";
                    continue;
                }
                else if (prop.PropertyType == typeof(DateTime))
                {
                    dictionary[prop.Name] = "System.String";
                    continue;
                }
                else if (prop.PropertyType == typeof(DateTimeOffset))
                {
                    dictionary[prop.Name] = "System.String";
                    continue;
                }
                else if (prop.PropertyType.IsEnum)
                {
                    if (settings != null)
                    {
                        if (settings.EnumConvert == EnumConvert.Int)
                        {
                            dictionary[prop.Name] = "System.Int32";
                            continue;
                        }
                        else
                        {
                            dictionary[prop.Name] = "System.String";
                            continue;
                        }
                    }
                    else
                    {
                        dictionary[prop.Name] = "System.String";
                        continue;
                    }
                }
                if (prop.PropertyType.IsArray)
                {
                    string propTypelName = prop.PropertyType.Name.TrimEnd(new char[] { '[', ']' });
                    dictionary[prop.Name] = $"{prop.PropertyType}";

                    if (prop.PropertyType.GetElementType().IsClass && propTypelName != "String")
                    {
                        dictionary[prop.Name] = $"{prop.PropertyType.Name}";

                        DeclareAsClass(prop.PropertyType.GetElementType().Name,
                                        prop.PropertyType.GetElementType().FullName,
                                        nmspace,
                                        prop.PropertyType.GetElementType().Name,
                                        prop.PropertyType.GetElementType(),
                                        classLayout,
                                        dictionary,
                                        classDublicates,
                                        settings,
                                        false);
                    }
                    continue;

                    //else
                    //{
                    //    string propName = prop.PropertyType.GetElementType().Name.TrimEnd(new char[] { '[', ']' });
                    //    string propFullName = prop.PropertyType.GetElementType().FullName.TrimEnd(new char[] { '[', ']' });
                    //
                    //    DeclareAsClass(propName, propFullName, propName, prop.PropertyType.GetElementType(), classLayout, dictionary, classDublicates, false);
                    //
                    //    continue;
                    //}
                }
                else if (prop.PropertyType.IsGenericType && prop.PropertyType.GetGenericTypeDefinition() == typeof(List<>))
                {
                    if (prop.PropertyType.GetGenericArguments()[0] == typeof(Nullable<>))
                    {

                    }

                    dictionary[prop.Name] = $"List<{prop.PropertyType.GenericTypeArguments[0].Name}>";

                    if (prop.PropertyType.IsClass && prop.PropertyType.GetGenericArguments()[0].Name != "String")
                    {
                        DeclareAsClass(prop.PropertyType.GenericTypeArguments[0].Name,
                                    prop.PropertyType.GenericTypeArguments[0].FullName,
                                    nmspace,
                                    prop.PropertyType.GenericTypeArguments[0].Name,
                                    prop.PropertyType.GenericTypeArguments[0],
                                    classLayout,
                                    dictionary,
                                    classDublicates,
                                    settings,
                                    false);
                    }

                    continue;
                }

                else if (prop.PropertyType.IsGenericType && prop.PropertyType.GetGenericTypeDefinition() == typeof(Dictionary<,>)
                    || prop.PropertyType.IsGenericType && prop.PropertyType.GetGenericTypeDefinition() == typeof(IDictionary<,>))
                {
                    if (prop.PropertyType.GetGenericArguments()[0].IsClass && prop.PropertyType.GetGenericArguments()[0].Name != "String")
                    {
                        ClassLayout dicClass = new ClassLayout
                        {
                            Name = prop.Name,
                            FullName = prop.PropertyType.FullName,
                            Type = prop.Name,
                            CreateAsProperty = true,
                            Properties = new Dictionary<string, dynamic>(),
                            ClassCollection = new List<ClassLayout>()
                        };

                        classLayout.ClassCollection.Add(dicClass);

                        dictionary[prop.Name] = dicClass;

                        DeclareAsClass(prop.PropertyType.GetGenericArguments()[0].Name,
                                           prop.PropertyType.GetGenericArguments()[0].FullName,
                                           nmspace,
                                           prop.PropertyType.GetGenericArguments()[0].Name,
                                           prop.PropertyType.GetGenericArguments()[0],
                                           classLayout,
                                           dictionary,
                                           classDublicates,
                                           settings,
                                           false);

                        dicClass.Properties.Add("Key", prop.PropertyType.GetGenericArguments()[0].Name);


                        if (prop.PropertyType.GetGenericArguments()[1].IsClass && prop.PropertyType.GetGenericArguments()[1] != typeof(string))
                        {
                            DeclareAsClass(prop.PropertyType.GetGenericArguments()[1].Name,
                                           prop.PropertyType.GetGenericArguments()[1].FullName,
                                           nmspace,
                                           prop.PropertyType.GetGenericArguments()[1].Name,
                                           prop.PropertyType.GetGenericArguments()[1],
                                           classLayout,
                                           dictionary,
                                           classDublicates,
                                           settings,
                                           false);

                            dicClass.Properties.Add("Value", prop.PropertyType.GetGenericArguments()[1].Name);
                        }
                        else
                        {
                            dicClass.Properties.Add("Value", GetClassPropertyType(prop.PropertyType.GetGenericArguments()[1], settings));
                        }

                        continue;
                    }
                    else
                    {
                        dictionary[prop.Name] = $"Dictionary<string, {GetClassPropertyType(prop.PropertyType.GetGenericArguments()[1], settings)}>";

                        if (prop.PropertyType.GetGenericArguments()[1].IsClass && prop.PropertyType.GetGenericArguments()[1] != typeof(string))
                        {
                            DeclareAsClass(prop.PropertyType.GetGenericArguments()[1].Name,
                                           prop.PropertyType.GetGenericArguments()[1].FullName,
                                           nmspace,
                                           prop.PropertyType.GetGenericArguments()[1].Name,
                                           prop.PropertyType.GetGenericArguments()[1],
                                           classLayout,
                                           dictionary,
                                           classDublicates,
                                           settings,
                                           false);
                        }
                    }

                    continue;
                }
                else if (prop.PropertyType == typeof(Guid))
                {
                    dictionary[prop.Name] = "System.String";
                    continue;
                }
                else if (prop.PropertyType == typeof(bool))
                {
                    dictionary[prop.Name] = "System.Boolean";
                    continue;
                }
                else if (prop.PropertyType == typeof(double))
                {
                    dictionary[prop.Name] = "System.Double";
                    continue;
                }
                else if (prop.PropertyType == typeof(decimal))
                {
                    dictionary[prop.Name] = "System.Double";
                    continue;
                }
                else if (prop.PropertyType == typeof(float))
                {
                    dictionary[prop.Name] = "System.Single";

                    continue;
                }
                //Checking if is nullable
                else if (Nullable.GetUnderlyingType(prop.PropertyType) == typeof(int?)
                      || Nullable.GetUnderlyingType(prop.PropertyType) == typeof(double?)
                      || Nullable.GetUnderlyingType(prop.PropertyType) == typeof(decimal?)
                      || Nullable.GetUnderlyingType(prop.PropertyType) == typeof(float?)
                      || Nullable.GetUnderlyingType(prop.PropertyType) == typeof(long?)
                      || Nullable.GetUnderlyingType(prop.PropertyType) == typeof(bool?)
                      || Nullable.GetUnderlyingType(prop.PropertyType) == typeof(DateTimeOffset?)
                      || Nullable.GetUnderlyingType(prop.PropertyType) == typeof(DateTime?)
                      || Nullable.GetUnderlyingType(prop.PropertyType) == typeof(Guid?)
                      || prop.PropertyType.IsGenericType &&
                            prop.PropertyType.GetGenericTypeDefinition() == typeof(Nullable<>))
                {
                    Type u = Nullable.GetUnderlyingType(prop.PropertyType);
                    if (u != null && u.IsEnum)
                    {
                        if (settings != null)
                        {
                            if (settings.EnumConvert == EnumConvert.String)
                            {
                                dictionary[prop.Name] = "int?";
                                continue;
                            }
                            else
                            {
                                dictionary[prop.Name] = "System.String";
                                continue;
                            }
                        }
                        else
                        {
                            dictionary[prop.Name] = "System.String";
                            continue;
                        }
                    }
                    else if (prop.PropertyType == typeof(int?))
                    {
                        dictionary[prop.Name] = "int?";
                        continue;
                    }
                    else if (prop.PropertyType == typeof(long?))
                    {
                        dictionary[prop.Name] = "long?";
                        continue;
                    }
                    else if (prop.PropertyType == typeof(DateTime?))
                    {
                        dictionary[prop.Name] = "System.String";
                        continue;
                    }
                    else if (prop.PropertyType == typeof(DateTimeOffset?))
                    {
                        dictionary[prop.Name] = "System.String";
                        continue;
                    }
                    else if (prop.PropertyType == typeof(Guid?))
                    {
                        dictionary[prop.Name] = "System.String";
                        continue;
                    }
                    else if (prop.PropertyType == typeof(bool?))
                    {
                        dictionary[prop.Name] = "System.Boolean?";
                        continue;
                    }
                    else if (prop.PropertyType == typeof(double?))
                    {
                        dictionary[prop.Name] = "double?";
                        continue;
                    }
                    else if (prop.PropertyType == typeof(decimal?))
                    {
                        dictionary[prop.Name] = "double?";
                        continue;
                    }
                    else if (prop.PropertyType == typeof(float?))
                    {
                        dictionary[prop.Name] = "float?";
                        continue;
                    }
                    else if (prop.PropertyType.IsClass && prop.PropertyType != typeof(string))
                    {
                        dictionary[prop.Name] = prop.PropertyType.Name;
                        DeclareAsClass(prop.Name, prop.PropertyType.FullName, nmspace, prop.PropertyType.Name, prop.PropertyType, classLayout, dictionary, classDublicates, settings);

                        continue;
                    }
                }
                else if (prop.PropertyType.IsClass && prop.PropertyType != typeof(string))
                {
                    //var a = prop.PropertyType.Namespace;                    
                    //dictionary[prop.Name] = prop.PropertyType.Name;
                    //dictionary[prop.Name] = prop.Name;
                    DeclareAsClass(prop.Name, prop.PropertyType.FullName, nmspace, prop.PropertyType.Name, prop.PropertyType, classLayout, dictionary, classDublicates, settings);

                    continue;
                }
            }

            return classLayout;
        }

        /// <summary>
        /// Set all prop in new class. Set Property collection, set AvroSchema for each class and set field _Schema with avro
        /// </summary>
        /// <param name="type"></param>
        /// <param name="classLayout"></param>
        /// <param name="classDublicates"></param>
        /// <param name="settings"></param>
        /// <returns></returns>
        private ClassLayout ClassGen(Type type, ClassLayout classLayout, List<ClassLayout> classDublicates, ClassGenerateSettings settings = null)
        {
            var dictionary = new Dictionary<string, dynamic>();
            classLayout.Properties = dictionary;
            classLayout.ClassCollection = new List<ClassLayout>();

            PropertyInfo[] properties = type.GetProperties(BindingFlags.Instance | BindingFlags.Public);

            var a = GetClassPropertyCollection(properties, classLayout, classLayout.Namespace, classDublicates, settings);

            var typee = classLayout.CreateType(type);
            var avroResult = _schemaGen.GetAvroPropertyCollection(typee, new List<AvroSchema>(), new AvroSchema(), true);

            if (settings != null && settings.IsSchemaInclude)
            {
                JsonSerializerSettings jsonSettings = new JsonSerializerSettings
                {
                    ReferenceLoopHandling = ReferenceLoopHandling.Ignore
                };

                var jsonConv = JsonConvert.SerializeObject(avroResult, jsonSettings);
                var res = JsonConvert.ToString(jsonConv);
                classLayout.Properties["_Schema"] = res;

                Console.WriteLine(JsonConvert.ToString(classLayout.Properties["_Schema"]));
            }

            return classLayout;
        }


        /// <summary>
        /// If setting is set to IsSeparateClasses = true this will generate different class file for each created file
        /// </summary>
        /// <param name="classLayout"></param>
        /// <param name="nameSpace"></param>
        /// <param name="dublicates"></param>
        /// <param name="settings"></param>
        private void GetSeparateClasses(ClassLayout classLayout, List<string> dublicates, ClassGenerateSettings settings)
        {
            if (!dublicates.Contains(classLayout.Namespace + $".{classLayout.Type}"))
            {
                //var tempClass = GetPropertyCollection(classLayout.GetType(), classLayout, new List<ClassLayout>(), settings);
                var result = CreateNameSpace(classLayout, classLayout.Type, true);
                WriteFile(result, classLayout.Type, "cs", classLayout.Namespace, settings.SaveFileDirectory);
                dublicates.Add(classLayout.Namespace + $".{classLayout.Type}");
            }

            foreach (var item in classLayout.ClassCollection)
            {
                GetSeparateClasses(item, dublicates, settings);
            }
        }

        /// <summary>
        /// Create NameSpace and return file as string
        /// </summary>
        /// <param name="classLayout"></param>
        /// <param name="className"></param>
        /// <param name="nameSpace"></param>
        /// <param name="isSeparateClasses"></param>
        /// <returns></returns>
        private string CreateNameSpace(ClassLayout classLayout, string className, bool isSeparateClasses = false)
        {
            CodeCompileUnit compileUnit = new CodeCompileUnit();

            CodeNamespace myNamespace = new CodeNamespace(classLayout.Namespace);
            myNamespace.Imports.Add(new CodeNamespaceImport("Avro"));
            compileUnit.Namespaces.Add(myNamespace);

            // Add the new class to the namespace            
            CreateClass(className, myNamespace, new HashSet<string>(), classLayout, isSeparateClasses);

            // Generate the C# code for the class
            return GenerateCode(compileUnit);
        }        


        /// <summary>
        /// Create C# code 
        /// Set properties names and values
        /// Set fields names and values
        /// Set attributes on fields and properties
        /// Set using
        /// etc
        /// </summary>
        /// <param name="classTypeName"></param>
        /// <param name="myNamespace"></param>
        /// <param name="checkingForDuplicates"></param>
        /// <param name="classLayout"></param>
        /// <param name="isSeparateClasses"></param>
        /// <returns></returns>
        private CodeTypeDeclaration CreateClass(string classTypeName, CodeNamespace myNamespace, HashSet<string> checkingForDuplicates, ClassLayout classLayout, bool isSeparateClasses = false)
        {
            CodeTypeDeclaration classType = new CodeTypeDeclaration(classTypeName);
            
            checkingForDuplicates.Add(classTypeName);
            myNamespace.Types.Add(classType);
            
            Console.WriteLine($"Creating class with name: {classTypeName}");

            foreach (var kvp in classLayout.Properties)
            {
                var test = kvp.Value.GetType();

                if(kvp.Key.ToString() == "_Schema")
                {
                    CodeMemberField field = new CodeMemberField();

                    field.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static;
                    field.Name = "_Schema";
                    field.Type = new CodeTypeReference("Schema");

                    field.Name += " = Avro.Schema.Parse(" + kvp.Value + ")";

                    classType.Members.Add(field);
                }
                else if (kvp.Value.GetType().IsClass && kvp.Value.GetType() != typeof(string))
                {
                    if (kvp.Value.CreateAsProperty)
                    {
                        classType.Members.Add(CreateField(kvp.Key, kvp.Value.Type));
                        classType.Members.Add(CreateProperty(kvp.Key, kvp.Value.Type));
                    }
                }
                else
                {
                    classType.Members.Add(CreateField(kvp.Key, kvp.Value));
                    classType.Members.Add(CreateProperty(kvp.Key, kvp.Value));
                };

                Console.WriteLine($"Property name: {kvp.Key} Property type: {kvp.Value.GetType()}");
            }

            if (isSeparateClasses)
            {
                return classType;
            }

            foreach (var kvp in classLayout.ClassCollection)
            {
                var tempType = kvp.Namespace + $".{kvp.Type}";
                if (!checkingForDuplicates.Contains(tempType))
                {
                    //CreateClass(kvp.Type, myNamespace, checkingForDuplicates, kvp);
                    CreateClass(tempType, myNamespace, checkingForDuplicates, kvp);
                }
            }

            return classType;
        }

        /// <summary>
        /// Create constructor for class
        /// It is not used yet
        /// </summary>
        /// <returns></returns>
        private CodeConstructor CreateConstructor()
        {
            // Create a new CodeConstructor
            CodeConstructor constructor = new CodeConstructor();

            // Set the accessibility of the constructor to "public"
            constructor.Attributes = MemberAttributes.Public;

            return constructor;
        }

        /// <summary>
        /// Create Property
        /// Get Set
        /// </summary>
        /// <param name="name"></param>
        /// <param name="typeName"></param>
        /// <returns></returns>
        private CodeMemberProperty CreateProperty(string name, string typeName)
        {
            CodeMemberProperty property = new CodeMemberProperty();

            property.Attributes = MemberAttributes.Public | MemberAttributes.Final;
            property.Name = name;

            property.Type = new CodeTypeReference(typeName);


            property.GetStatements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression("this._" + name.ToLower())));
            property.SetStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression("this._" + name.ToLower()), new CodeVariableReferenceExpression("value")));

            //property.Name += " { get; set;}//";

            return property;
        }

        /// <summary>
        /// Create field
        /// field value
        /// etc
        /// </summary>
        /// <param name="name"></param>
        /// <param name="typeName"></param>
        /// <returns></returns>
        private CodeMemberField CreateField(string name, string typeName)
        {
            CodeMemberField field = new CodeMemberField();
            field.Attributes = MemberAttributes.Private;
            field.Name = "_" + name.ToLower();
            field.Type = new CodeTypeReference(typeName);

            return field;
        }

        /// <summary>
        /// generate C# code and retun it as string
        /// codeOptions.BracingStyle = "C"; - each { to be on new line just style
        /// </summary>
        /// <param name="compileUnit"></param>
        /// <returns></returns>
        private string GenerateCode(CodeCompileUnit compileUnit)
        {
            // Create a C# code provider
            CSharpCodeProvider provider = new CSharpCodeProvider();

            // Create a TextWriter to receive the generated code
            using (StringWriter writer = new StringWriter())
            {
                CodeGeneratorOptions codeOptions = new CodeGeneratorOptions();
                codeOptions.BracingStyle = "C";
                // Generate the code and write it to the TextWriter
                provider.GenerateCodeFromCompileUnit(compileUnit, writer, codeOptions);

                // Return the generated code
                return writer.ToString();
            }
        }

        /// <summary>
        /// Used to set if any property is class type and must be declared as type or is just a property
        /// </summary>
        /// <param name="className"></param>
        /// <param name="classFullName"></param>
        /// <param name="classTypeName"></param>
        /// <param name="propType"></param>
        /// <param name="parentClass"></param>
        /// <param name="dictionary"></param>
        /// <param name="classDublicates"></param>
        /// <param name="settings"></param>
        /// <param name="createAsProperty"></param>
        /// <returns></returns>
        private ClassLayout DeclareAsClass(string className, string classFullName, string nmspace, string classTypeName, Type propType, ClassLayout parentClass, Dictionary<string, dynamic> dictionary, List<ClassLayout> classDublicates, ClassGenerateSettings settings = null, bool createAsProperty = true)
        {
            ClassLayout classLayout = new ClassLayout();
            classLayout.Name = className;
            classLayout.FullName = classFullName;
            classLayout.Type = classTypeName;
            classLayout.CreateAsProperty = createAsProperty;
            classLayout.Properties = new Dictionary<string, dynamic>();
            classLayout.Namespace = nmspace;
            dictionary[className] = classLayout;

            parentClass.ClassCollection.Add(classLayout);

            var getDublicateClass = classDublicates.FirstOrDefault(x => x.FullName == classLayout.FullName);
            if (getDublicateClass == null)
            {
                //If colleciton contains class but it is different one with same name (Stream -> Stream.TennisStream) but there is different Stream class
                if (classDublicates.Select(x => x.Type).Contains(classLayout.Type))
                {
                    var sepName = classFullName.Split('.', StringSplitOptions.RemoveEmptyEntries).ToArray();
                    if (sepName.Contains(classLayout.Type))
                    {
                        var index = Array.IndexOf(sepName, classLayout.Type);
                        var nspace = nmspace + '.' + sepName[index - 1] + '.' + classLayout.Type;
                        classLayout.Namespace = nspace;
                        dictionary[className] = nspace + $".{classLayout.Type}";
                    }
                    else
                    {
                        classLayout.Type = className;
                        //var nspace = nmspace + '.' + sepName[sepName.Length - 1] + '.' + classLayout.Type;
                        dictionary[className] = classLayout.Type;
                    } 
                }

                classDublicates.Add(classLayout);
                Type tempType = propType;
                ClassGen(tempType, classLayout, classDublicates, settings);
            }
            else
            {
                classLayout.Properties = getDublicateClass.Properties;
                classLayout.ClassCollection = getDublicateClass.ClassCollection;
            }

            return classLayout;
        }

        /// <summary>
        /// Check type and set property for simple types. Just a helper
        /// </summary>
        /// <param name="type"></param>
        /// <param name="settings"></param>
        /// <returns></returns>
        private string GetClassPropertyType(Type type, ClassGenerateSettings settings)
        {
            if (type == typeof(int))
            {
                return "int";
            }
            if (type == typeof(long))
            {
                return "long";
            }
            else if (type == typeof(string))
            {
                return "string";
            }
            else if (type == typeof(DateTime))
            {
                return "string";
            }
            else if (type == typeof(DateTimeOffset))
            {
                return "string";
            }
            else if (type.IsEnum)
            {
                if (settings != null)
                {
                    if (settings.EnumConvert == EnumConvert.Int)
                    {
                        return "int";
                    }
                    else
                    {
                        return "string";
                    }
                }
                else
                {
                    return "string";
                }
            }
            else if (type == typeof(Guid))
            {
                return "string";
            }
            else if (type == typeof(bool))
            {
                return "bool";
            }
            else if (type == typeof(double))
            {
                return "double";
            }
            else if (type == typeof(decimal))
            {
                return "double";
            }
            else if (type == typeof(float))
            {
                return "double";
            }
            else if (type.IsClass)
            {
                return type.Name;
            }
            //Checking if is nullable
            else if (Nullable.GetUnderlyingType(type) == typeof(int?)
                  || Nullable.GetUnderlyingType(type) == typeof(double?)
                  || Nullable.GetUnderlyingType(type) == typeof(decimal?)
                  || Nullable.GetUnderlyingType(type) == typeof(float?)
                  || Nullable.GetUnderlyingType(type) == typeof(long?)
                  || Nullable.GetUnderlyingType(type) == typeof(bool?)
                  || Nullable.GetUnderlyingType(type) == typeof(DateTimeOffset?)
                  || Nullable.GetUnderlyingType(type) == typeof(DateTime?)
                  || Nullable.GetUnderlyingType(type) == typeof(Guid?)
                  || type.IsGenericType &&
                       type.GetGenericTypeDefinition() == typeof(Nullable<>))
            {
                Type u = Nullable.GetUnderlyingType(type);

                if (u != null && u.IsEnum)
                {
                    if (settings != null)
                    {
                        if (settings.EnumConvert == EnumConvert.Int)
                        {
                            return "int?";
                        }
                        else
                        {
                            return "string";
                        }
                    }
                    else
                    {
                        return "string";
                    }
                }
                else if (type == typeof(int?))
                {
                    return "int?";
                }
                else if (type == typeof(long?))
                {
                    return "long?";
                }
                else if (type == typeof(DateTime?))
                {
                    return "string";
                }
                else if (type == typeof(DateTimeOffset?))
                {
                    return "string";
                }
                else if (type == typeof(Guid?))
                {
                    return "string";
                }
                else if (type == typeof(bool?))
                {
                    return "bool?";
                }
                else if (type == typeof(double?))
                {
                    return "double?";
                }
                else if (type == typeof(decimal?))
                {
                    return "double?";
                }
                else if (type == typeof(float?))
                {
                    return "double?";
                }
                else if (type.IsClass)
                {
                    return type.Name + "?";
                }
                else
                {
                    return "undifinied";
                }
            }
            else
            {
                return "undifinied";
            }
        }

        #region used methods in old code
        //private string GetPropertyType(Type type, ClassGenerateSettings settings)
        //{
        //    if (type == typeof(int))
        //    {
        //        return "int";
        //    }
        //    if (type == typeof(long))
        //    {
        //        return "long";
        //    }
        //    else if (type == typeof(string))
        //    {
        //        return "string";
        //    }
        //    else if (type == typeof(DateTime))
        //    {
        //        return "string";
        //    }
        //    else if (type == typeof(DateTimeOffset))
        //    {
        //        return "string";
        //    }
        //    else if (type.IsEnum)
        //    {
        //        if (settings != null)
        //        {
        //            if (settings.EnumConvert == Enums.EnumConvert.Int)
        //            {
        //                return "int";
        //            }
        //            else
        //            {
        //                return "string";
        //            }
        //        }
        //        else
        //        {
        //            return "string";
        //        }
        //    }
        //    else if (type == typeof(Guid))
        //    {
        //        return "string";
        //    }
        //    else if (type == typeof(bool))
        //    {
        //        return "bool";
        //    }
        //    else if (type == typeof(double))
        //    {
        //        return "double";
        //    }
        //    else if (type == typeof(decimal))
        //    {
        //        return "double";
        //    }
        //    else if (type == typeof(float))
        //    {
        //        return "double";
        //    }
        //    else if (type.IsClass)
        //    {
        //        return type.Name;
        //    }
        //    //Checking if is nullable
        //    else if (Nullable.GetUnderlyingType(type) == typeof(int?)
        //          || Nullable.GetUnderlyingType(type) == typeof(double?)
        //          || Nullable.GetUnderlyingType(type) == typeof(decimal?)
        //          || Nullable.GetUnderlyingType(type) == typeof(float?)
        //          || Nullable.GetUnderlyingType(type) == typeof(long?)
        //          || Nullable.GetUnderlyingType(type) == typeof(bool?)
        //          || Nullable.GetUnderlyingType(type) == typeof(DateTimeOffset?)
        //          || Nullable.GetUnderlyingType(type) == typeof(DateTime?)
        //          || Nullable.GetUnderlyingType(type) == typeof(Guid?)
        //          || type.IsGenericType &&
        //               type.GetGenericTypeDefinition() == typeof(Nullable<>))
        //    {
        //        Type u = Nullable.GetUnderlyingType(type);

        //        if (u != null && u.IsEnum)
        //        {
        //            if (settings != null)
        //            {
        //                if (settings.EnumConvert == Enums.EnumConvert.Int)
        //                {
        //                    return "int?";
        //                }
        //                else
        //                {
        //                    return "string";
        //                }
        //            }
        //            else
        //            {
        //                return "string";
        //            }
        //        }
        //        else if (type == typeof(int?))
        //        {
        //            return "int?";
        //        }
        //        else if (type == typeof(long?))
        //        {
        //            return "long?";
        //        }
        //        else if (type == typeof(DateTime?))
        //        {
        //            return "string";
        //        }
        //        else if (type == typeof(DateTimeOffset?))
        //        {
        //            return "string";
        //        }
        //        else if (type == typeof(Guid?))
        //        {
        //            return "string";
        //        }
        //        else if (type == typeof(bool?))
        //        {
        //            return "bool?";
        //        }
        //        else if (type == typeof(double?))
        //        {
        //            return "double?";
        //        }
        //        else if (type == typeof(decimal?))
        //        {
        //            return "double?";
        //        }
        //        else if (type == typeof(float?))
        //        {
        //            return "double?";
        //        }
        //        else if (type.IsClass)
        //        {
        //            return type.Name + "?";
        //        }
        //        else
        //        {
        //            return "undifinied";
        //        }
        //    }
        //    else
        //    {
        //        return "undifinied";
        //    }
        //}


        /// <summary>
        /// Working Version DONT DELETE
        /// </summary>
        /// <param name="classTypeName"></param>
        /// <param name="myNamespace"></param>
        /// <param name="checkingForDuplicates"></param>
        /// <param name="classLayout"></param>
        /// <param name="isSeparateClasses"></param>
        /// <returns></returns>
        //private ClassLayout GetPropertyCollection(Type type, ClassLayout classLayout, List<ClassLayout> classDublicates, ClassGenerateSettings settings = null)
        //{
        //    PropertyInfo[] properties = type.GetProperties(BindingFlags.Instance | BindingFlags.Public);
        //    var dictionary = new Dictionary<string, dynamic>();
        //    classLayout.Properties = dictionary;
        //    classLayout.ClassCollection = new List<ClassLayout>();

        //    foreach (var prop in properties)
        //    {
        //        if (prop.Name == "SoccerStatistics")
        //        {

        //        }

        //        if (prop.PropertyType == typeof(int))
        //        {
        //            dictionary[prop.Name] = "System.Int32";
        //            continue;
        //        }
        //        if (prop.PropertyType == typeof(long))
        //        {
        //            dictionary[prop.Name] = "System.Int64";
        //            continue;
        //        }
        //        else if (prop.PropertyType == typeof(string))
        //        {
        //            dictionary[prop.Name] = "System.String";
        //            continue;
        //        }
        //        else if (prop.PropertyType == typeof(DateTime))
        //        {
        //            dictionary[prop.Name] = "System.String";
        //            continue;
        //        }
        //        else if (prop.PropertyType == typeof(DateTimeOffset))
        //        {
        //            dictionary[prop.Name] = "System.String";
        //            continue;
        //        }
        //        else if (prop.PropertyType.IsEnum)
        //        {
        //            if (settings != null)
        //            {
        //                if (settings.EnumConvert == Enums.EnumConvert.Int)
        //                {
        //                    dictionary[prop.Name] = "System.Int32";
        //                    continue;
        //                }
        //                else
        //                {                            
        //                    dictionary[prop.Name] = "System.String";
        //                    continue;
        //                }
        //            }
        //            else
        //            {
        //                dictionary[prop.Name] = "System.String";
        //                continue;
        //            }
        //        }
        //        if (prop.PropertyType.IsArray)
        //        {
        //            string propTypelName = prop.PropertyType.Name.TrimEnd(new char[] { '[', ']' });
        //            dictionary[prop.Name] = $"{prop.PropertyType}";

        //            if (prop.PropertyType.GetElementType().IsClass && propTypelName != "String")
        //            {
        //                dictionary[prop.Name] = $"{prop.PropertyType.Name}";

        //                DeclareAsClass(prop.PropertyType.GetElementType().Name,
        //                                prop.PropertyType.GetElementType().FullName,
        //                                prop.PropertyType.GetElementType().Name,
        //                                prop.PropertyType.GetElementType(),
        //                                classLayout,
        //                                dictionary,
        //                                classDublicates,
        //                                false);
        //                continue;
        //            }
        //            else
        //            {
        //                string propName = prop.PropertyType.GetElementType().Name.TrimEnd(new char[] { '[', ']' });
        //                string propFullName = prop.PropertyType.GetElementType().FullName.TrimEnd(new char[] { '[', ']' });

        //                DeclareAsClass(propName, propFullName, propName, prop.PropertyType.GetElementType(), classLayout, dictionary, classDublicates, false);

        //                continue;
        //            }
        //        }
        //        else if (prop.PropertyType.IsGenericType && prop.PropertyType.GetGenericTypeDefinition() == typeof(List<>))
        //        {
        //            if (prop.PropertyType.GetGenericArguments()[0] == typeof(Nullable<>))
        //            {

        //            }

        //            dictionary[prop.Name] = $"List<{prop.PropertyType.GenericTypeArguments[0].Name}>";

        //            if (prop.PropertyType.IsClass && prop.PropertyType.GetGenericArguments()[0].Name != "String")
        //            {
        //                DeclareAsClass(prop.PropertyType.GenericTypeArguments[0].Name,
        //                            prop.PropertyType.GenericTypeArguments[0].FullName,
        //                            prop.PropertyType.GenericTypeArguments[0].Name,
        //                            prop.PropertyType.GenericTypeArguments[0],
        //                            classLayout,
        //                            dictionary,
        //                            classDublicates,
        //                            false);
        //            }

        //            continue;
        //        }

        //        else if (prop.PropertyType.IsGenericType && prop.PropertyType.GetGenericTypeDefinition() == typeof(Dictionary<,>)
        //            || prop.PropertyType.IsGenericType && prop.PropertyType.GetGenericTypeDefinition() == typeof(IDictionary<,>))
        //        {
        //            if (prop.PropertyType.GetGenericArguments()[0].IsClass && prop.PropertyType.GetGenericArguments()[0].Name != "String")
        //            {
        //                ClassLayout dicClass = new ClassLayout
        //                {
        //                    Name = prop.Name,
        //                    FullName = prop.PropertyType.FullName,
        //                    Type = prop.Name,
        //                    CreateAsProperty = true,
        //                    Properties = new Dictionary<string, dynamic>(),
        //                    ClassCollection = new List<ClassLayout>()
        //                };

        //                classLayout.ClassCollection.Add(dicClass);

        //                dictionary[prop.Name] = dicClass;

        //                DeclareAsClass(prop.PropertyType.GetGenericArguments()[0].Name,
        //                                   prop.PropertyType.GetGenericArguments()[0].FullName,
        //                                   prop.PropertyType.GetGenericArguments()[0].Name,
        //                                   prop.PropertyType.GetGenericArguments()[0],
        //                                   classLayout,
        //                                   dictionary,
        //                                   classDublicates,
        //                                   false);

        //                dicClass.Properties.Add("Key", prop.PropertyType.GetGenericArguments()[0].Name);


        //                if (prop.PropertyType.GetGenericArguments()[1].IsClass && prop.PropertyType.GetGenericArguments()[1] != typeof(string))
        //                {
        //                    DeclareAsClass(prop.PropertyType.GetGenericArguments()[1].Name,
        //                                   prop.PropertyType.GetGenericArguments()[1].FullName,
        //                                   prop.PropertyType.GetGenericArguments()[1].Name,
        //                                   prop.PropertyType.GetGenericArguments()[1],
        //                                   classLayout,
        //                                   dictionary,
        //                                   classDublicates,
        //                                   false);

        //                    dicClass.Properties.Add("Value", prop.PropertyType.GetGenericArguments()[1].Name);
        //                }
        //                else
        //                {
        //                    dicClass.Properties.Add("Value", GetPropertyType(prop.PropertyType.GetGenericArguments()[1], settings));
        //                }

        //                continue;
        //            }
        //            else
        //            {
        //                dictionary[prop.Name] = $"Dictionary<string, {GetPropertyType(prop.PropertyType.GetGenericArguments()[1], settings)}>";

        //                if (prop.PropertyType.GetGenericArguments()[1].IsClass && prop.PropertyType.GetGenericArguments()[1] != typeof(string))
        //                {
        //                    DeclareAsClass(prop.PropertyType.GetGenericArguments()[1].Name,
        //                                   prop.PropertyType.GetGenericArguments()[1].FullName,
        //                                   prop.PropertyType.GetGenericArguments()[1].Name,
        //                                   prop.PropertyType.GetGenericArguments()[1],
        //                                   classLayout,
        //                                   dictionary,
        //                                   classDublicates,
        //                                   false);
        //                }
        //            }

        //            continue;
        //        }
        //        else if (prop.PropertyType == typeof(Guid))
        //        {
        //            dictionary[prop.Name] = "System.String";
        //            continue;
        //        }
        //        else if (prop.PropertyType == typeof(bool))
        //        {
        //            dictionary[prop.Name] = "System.Boolean";
        //            continue;
        //        }
        //        else if (prop.PropertyType == typeof(double))
        //        {
        //            dictionary[prop.Name] = "System.Double";
        //            continue;
        //        }
        //        else if (prop.PropertyType == typeof(decimal))
        //        {
        //            dictionary[prop.Name] = "System.Double";
        //            continue;
        //        }
        //        else if (prop.PropertyType == typeof(float))
        //        {
        //            dictionary[prop.Name] = "System.Double";

        //            continue;
        //        }
        //        //Checking if is nullable
        //        else if (Nullable.GetUnderlyingType(prop.PropertyType) == typeof(int?)
        //              || Nullable.GetUnderlyingType(prop.PropertyType) == typeof(double?)
        //              || Nullable.GetUnderlyingType(prop.PropertyType) == typeof(decimal?)
        //              || Nullable.GetUnderlyingType(prop.PropertyType) == typeof(float?)
        //              || Nullable.GetUnderlyingType(prop.PropertyType) == typeof(long?)
        //              || Nullable.GetUnderlyingType(prop.PropertyType) == typeof(bool?)
        //              || Nullable.GetUnderlyingType(prop.PropertyType) == typeof(DateTimeOffset?)
        //              || Nullable.GetUnderlyingType(prop.PropertyType) == typeof(DateTime?)
        //              || Nullable.GetUnderlyingType(prop.PropertyType) == typeof(Guid?)
        //              || prop.PropertyType.IsGenericType &&
        //                    prop.PropertyType.GetGenericTypeDefinition() == typeof(Nullable<>))
        //        {
        //            Type u = Nullable.GetUnderlyingType(prop.PropertyType);
        //            if (u != null && u.IsEnum)
        //            {
        //                if (settings != null)
        //                {
        //                    if (settings.EnumConvert == Enums.EnumConvert.String)
        //                    {
        //                        dictionary[prop.Name] = "int?";
        //                        continue;
        //                    }
        //                    else
        //                    {                               
        //                        dictionary[prop.Name] = "System.String";
        //                        continue;
        //                    }
        //                }
        //                else
        //                {
        //                    dictionary[prop.Name] = "System.String";
        //                    continue;
        //                }
        //            }
        //            else if (prop.PropertyType == typeof(int?))
        //            {
        //                dictionary[prop.Name] = "int?";
        //                continue;
        //            }
        //            else if (prop.PropertyType == typeof(long?))
        //            {
        //                dictionary[prop.Name] = "long?";
        //                continue;
        //            }
        //            else if (prop.PropertyType == typeof(DateTime?))
        //            {
        //                dictionary[prop.Name] = "System.String";
        //                continue;
        //            }
        //            else if (prop.PropertyType == typeof(DateTimeOffset?))
        //            {
        //                dictionary[prop.Name] = "System.String";
        //                continue;
        //            }
        //            else if (prop.PropertyType == typeof(Guid?))
        //            {
        //                dictionary[prop.Name] = "System.String";
        //                continue;
        //            }
        //            else if (prop.PropertyType == typeof(bool?))
        //            {
        //                dictionary[prop.Name] = "System.Boolean?";
        //                continue;
        //            }
        //            else if (prop.PropertyType == typeof(double?))
        //            {
        //                dictionary[prop.Name] = "double?";
        //                continue;
        //            }
        //            else if (prop.PropertyType == typeof(decimal?))
        //            {
        //                dictionary[prop.Name] = "double?";
        //                continue;
        //            }
        //            else if (prop.PropertyType == typeof(float?))
        //            {
        //                dictionary[prop.Name] = "double?";
        //                continue;
        //            }
        //            else if (prop.PropertyType.IsClass && prop.PropertyType != typeof(string))
        //            {
        //                dictionary[prop.Name] = prop.PropertyType.Name;
        //                DeclareAsClass(prop.Name, prop.PropertyType.FullName, prop.PropertyType.Name, prop.PropertyType, classLayout, dictionary, classDublicates);

        //                continue;
        //            }
        //        }
        //        else if (prop.PropertyType.IsClass && prop.PropertyType != typeof(string))
        //        {
        //            dictionary[prop.Name] = prop.PropertyType.Name;
        //            //dictionary[prop.Name] = prop.Name;
        //            DeclareAsClass(prop.Name, prop.PropertyType.FullName, prop.PropertyType.Name, prop.PropertyType, classLayout, dictionary, classDublicates);

        //            continue;
        //        }
        //    }

        //    return classLayout;
        //}

        //private ClassLayout DeclareAsClass(string className, string classFullName, string classTypeName, Type propType, ClassLayout parentClass, Dictionary<string, dynamic> dictionary, List<ClassLayout> classDublicates, bool createAsProperty = true)
        //{
        //    ClassLayout classLayout = new ClassLayout();
        //    classLayout.Name = className;
        //    classLayout.FullName = classFullName;
        //    classLayout.Type = classTypeName;
        //    classLayout.CreateAsProperty = createAsProperty;
        //    classLayout.Properties = new Dictionary<string, dynamic>();

        //    //dictionary[className] = classLayout;

        //    parentClass.ClassCollection.Add(classLayout);

        //    var getDublicateClass = classDublicates.FirstOrDefault(x => x.FullName == classLayout.FullName);
        //    if (getDublicateClass == null)
        //    {
        //        if (classDublicates.Select(x => x.Type).Contains(classLayout.Type))
        //        {
        //            classLayout.Type = className;
        //            dictionary[className] = classLayout.Type;
        //        }

        //        classDublicates.Add(classLayout);
        //        Type tempType = propType;
        //        GetPropertyCollection(tempType, classLayout, classDublicates);
        //    }
        //    else
        //    {
        //        classLayout.Properties = getDublicateClass.Properties;
        //        classLayout.ClassCollection = getDublicateClass.ClassCollection;
        //    }

        //    return classLayout;
        //}


        //public void GenerateSeparateClassesFilesFromExistingClass<T>(string className = null, string nameSpace = null, ClassGenerateSettings settings = null) where T : class
        //{
        //    var genClass = new ClassLayout()
        //    {
        //        Name = className,
        //        ClassCollection = new List<ClassLayout>(),
        //        Properties = new Dictionary<string, dynamic>()
        //    };
        //
        //    GetPropertyCollection(typeof(T), genClass, new List<ClassLayout>(), settings);
        //
        //    GetSeparateClasses(genClass, settings, nameSpace);
        //}
        #endregion
    }
}
